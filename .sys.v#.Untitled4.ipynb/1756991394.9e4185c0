{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "592c7e2d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n"
     ]
    }
   ],
   "source": [
    "import time\n",
    "start = time.time()\n",
    "import os\n",
    "import ROOT\n",
    "from ROOT import RDataFrame, RVec\n",
    "from ROOT import TChain, TSelector, TTree, TH1F, TCanvas, TFile, TEfficiency, TLegend\n",
    "from ROOT import Math\n",
    "from ROOT import TLorentzVector\n",
    "from ROOT import TVector3\n",
    "from array import array\n",
    "import numpy as np\n",
    "\n",
    "# Reset ROOT interpreter to avoid redefinition errors\n",
    "ROOT.gInterpreter.Reset()\n",
    "\n",
    "ROOT.EnableImplicitMT()\n",
    "print(ROOT.ROOT.IsImplicitMTEnabled())\n",
    "ROOT.gROOT.SetBatch(ROOT.kTRUE)  # Keep batch mode for non-interactive environments\n",
    "folder=\"/eos/user/f/fsimone/B_Dh_summerproject/bphnano/B_to_Dpi_pipipi_Run3Summer24NanoAOD_v0_2025Aug27/B_to_Dpi_pipipi__TuneCP5_13p6TeV_pythia8_Run3Summer24GS_v1/B_to_Dpi_pipipi__Run3Summer24NanoAOD_v0/250827_105152/\"\n",
    "tree=TChain(\"Events\")\n",
    "for fol,subfolders,files in os.walk(folder):\n",
    "    for file in files:\n",
    "        if file.endswith(\".root\"):\n",
    "            tree.Add(fol+\"/\"+file)\n",
    "\n",
    "\n",
    "df = RDataFrame(tree)\n",
    "decay=\"pipipi\"\n",
    "id1 = 211\n",
    "id2 = -211\n",
    "id3 = 211\n",
    "t = False  # Set to False to bypass muon selection\n",
    "th1 = 0.01\n",
    "th2 = 0.01\n",
    "th3 = 0.01\n",
    "\n",
    "cpp_code = \"\"\"\n",
    "#include <ROOT/RVec.hxx>\n",
    "#include <Math/Vector4Dfwd.h>\n",
    "#include <Math/VectorUtil.h>\n",
    "#include <TDatabasePDG.h>\n",
    "#include <TMath.h>\n",
    "#include <map>\n",
    "#include <set>\n",
    "#include <tuple>\n",
    "#include <vector>\n",
    "#include <algorithm>\n",
    "#include <iterator>\n",
    "\n",
    "using namespace ROOT;\n",
    "using namespace ROOT::Math;\n",
    "\n",
    "using PtEtaPhiMVector = ROOT::Math::PtEtaPhiMVector;\n",
    "using GenParticle = std::tuple<PtEtaPhiMVector, int, int, float, float>;\n",
    "using Matched = std::tuple<PtEtaPhiMVector, int, PtEtaPhiMVector>;\n",
    "\n",
    "std::vector<Matched> matching_m(const RVec<float>& g_eta, const RVec<float>& g_phi, const RVec<float>& g_pt, const RVec<float>& g_mass, const RVec<int>& g_midx,\n",
    "                                const std::vector<Matched>& p, const std::vector<Matched>& m,\n",
    "                                RVec<float>& hDen, RVec<float>& hNum, RVec<float>& hdR, float th, RVec<float>& hIM) {\n",
    "    std::vector<Matched> matches;\n",
    "    for (const auto& plus : p) {\n",
    "        for (const auto& minus_ : m) {\n",
    "            if (std::get<1>(plus) == std::get<1>(minus_)) {\n",
    "                int idx = std::get<1>(plus);\n",
    "                PtEtaPhiMVector GenMother(g_pt[idx], g_eta[idx], g_phi[idx], g_mass[idx]);\n",
    "                PtEtaPhiMVector RecoMother = std::get<2>(plus) + std::get<2>(minus_);\n",
    "                float dr = VectorUtil::DeltaR(GenMother, RecoMother);\n",
    "                hIM.push_back(RecoMother.M());\n",
    "                hdR.push_back(dr);\n",
    "                if (dr < th) {\n",
    "                    hNum.push_back(g_pt[idx]);\n",
    "                    matches.emplace_back(GenMother, g_midx[idx], RecoMother);\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    return matches;\n",
    "}\n",
    "\n",
    "// ****** CORREZIONE 1: Aggiunti id1, id2, id3 alla firma della funzione ******\n",
    "void matching_func(std::vector<GenParticle>& Gp, std::vector<PtEtaPhiMVector>& Tp,\n",
    "                   RVec<float>& d1_num_pt, RVec<float>& d2_num_pt, RVec<float>& d3_num_pt,\n",
    "                   RVec<float>& d1_num_d, RVec<float>& d2_num_d, RVec<float>& d3_num_d,\n",
    "                   RVec<float>& d1_dr, RVec<float>& d2_dr, RVec<float>& d3_dr,\n",
    "                   std::vector<Matched>& m1, std::vector<Matched>& m2, std::vector<Matched>& m3,\n",
    "                   float th1, float th2, float th3, int id1, int id2, int id3) {\n",
    "    TDatabasePDG *pdg_db = TDatabasePDG::Instance();\n",
    "    bool go = true;\n",
    "    while (go) {\n",
    "        go = false;\n",
    "        std::map<int, std::set<std::pair<int, float>>> match_map;\n",
    "        int i = 0;\n",
    "        while (i < Gp.size()) {\n",
    "            float dR0 = 1000.0f;\n",
    "            int idx = 0;\n",
    "            for (int j = 0; j < Tp.size(); ++j) {\n",
    "                float dR = VectorUtil::DeltaR(std::get<0>(Gp[i]), Tp[j]);\n",
    "                if (dR < dR0) {\n",
    "                    dR0 = dR;\n",
    "                    idx = j;\n",
    "                }\n",
    "            }\n",
    "            int typ = std::get<2>(Gp[i]);\n",
    "            float th = (typ == 1 ? th1 : (typ == 2 ? th2 : th3));\n",
    "            if (dR0 < th) {\n",
    "                auto& s = match_map[idx];\n",
    "                s.emplace(i, dR0);\n",
    "                if (s.size() > 1) go = true;\n",
    "                ++i;\n",
    "            } else {\n",
    "                if (typ == 1) d1_dr.push_back(dR0);\n",
    "                else if (typ == 2) d2_dr.push_back(dR0);\n",
    "                else d3_dr.push_back(dR0);\n",
    "                Gp.erase(Gp.begin() + i);\n",
    "            }\n",
    "        }\n",
    "        std::vector<int> l_g, l_t;\n",
    "        for (const auto& kv : match_map) {\n",
    "            int e = kv.first;\n",
    "            const auto& s = kv.second;\n",
    "            float dr = 1000.0f;\n",
    "            int ind = 0;\n",
    "            for (const auto& el : s) {\n",
    "                if (el.second < dr) {\n",
    "                    dr = el.second;\n",
    "                    ind = el.first;\n",
    "                }\n",
    "            }\n",
    "            int typ = std::get<2>(Gp[ind]);\n",
    "            // Ora questa riga funziona perchÃ© id1, id2, id3 sono noti alla funzione\n",
    "            int pdgid = (typ == 1) ? id1 : ((typ == 2) ? id2 : id3);\n",
    "            double mass = pdg_db->GetParticle(pdgid)->Mass();\n",
    "            Tp[e] = PtEtaPhiMVector(Tp[e].Pt(), Tp[e].Eta(), Tp[e].Phi(), mass);\n",
    "            if (typ == 1) {\n",
    "                d1_num_pt.push_back(std::get<3>(Gp[ind]));\n",
    "                d1_dr.push_back(dr);\n",
    "                d1_num_d.push_back(std::get<4>(Gp[ind]));\n",
    "                m1.emplace_back(std::get<0>(Gp[ind]), std::get<1>(Gp[ind]), Tp[e]);\n",
    "            } else if (typ == 2) {\n",
    "                d2_num_pt.push_back(std::get<3>(Gp[ind]));\n",
    "                d2_dr.push_back(dr);\n",
    "                d2_num_d.push_back(std::get<4>(Gp[ind]));\n",
    "                m2.emplace_back(std::get<0>(Gp[ind]), std::get<1>(Gp[ind]), Tp[e]);\n",
    "            } else {\n",
    "                d3_num_pt.push_back(std::get<3>(Gp[ind]));\n",
    "                d3_dr.push_back(dr);\n",
    "                d3_num_d.push_back(std::get<4>(Gp[ind]));\n",
    "                m3.emplace_back(std::get<0>(Gp[ind]), std::get<1>(Gp[ind]), Tp[e]);\n",
    "            }\n",
    "            l_g.push_back(ind);\n",
    "            l_t.push_back(e);\n",
    "        }\n",
    "        std::sort(l_g.begin(), l_g.end(), std::greater<int>());\n",
    "        std::sort(l_t.begin(), l_t.end(), std::greater<int>());\n",
    "        for (auto eg : l_g) {\n",
    "            Gp.erase(Gp.begin() + eg);\n",
    "        }\n",
    "        for (auto et : l_t) {\n",
    "            Tp.erase(Tp.begin() + et);\n",
    "        }\n",
    "    }\n",
    "}\n",
    "\n",
    "std::vector<RVec<float>> main_func(const RVec<float>& g_pt, const RVec<float>& g_eta, const RVec<float>& g_phi, const RVec<float>& g_mass,\n",
    "                                   const RVec<int>& g_id, const RVec<int>& st, const RVec<int>& g_midx,\n",
    "                                   const RVec<float>& t_pt, const RVec<float>& t_eta, const RVec<float>& t_phi, const RVec<int>& t_ch, const RVec<float>& t_mass,\n",
    "                                   const RVec<float>& g_vx, const RVec<float>& g_vy, const RVec<float>& g_vz,\n",
    "                                   const RVec<float>& m_eta, const RVec<float>& m_pt, bool t_opt, int id1, int id2, int id3, float th1, float th2, float th3) {\n",
    "    TDatabasePDG *pdg = TDatabasePDG::Instance();\n",
    "    std::map<int, std::vector<GenParticle>> d;\n",
    "    std::vector<GenParticle> Gp, Gm;\n",
    "    RVec<float> d1_num_pt, d2_num_pt, d3_num_pt, d1_num_d, d2_num_d, d3_num_d, d1_den_pt, d2_den_pt, d3_den_pt, d1_den_d, d2_den_d, d3_den_d, d1_dr, d2_dr, d3_dr;\n",
    "    RVec<float> B_num_pt, D_num_pt, B_den_pt, D_den_pt, B_dr, D_dr, B_M, D_M;\n",
    "    RVec<float> d1_eta, d2_eta, d3_eta, d1_phi, d2_phi, d3_phi, d1_pt, d2_pt, d3_pt;\n",
    "    bool go = false;\n",
    "    if (t_opt) {\n",
    "        for (size_t im = 0; im < m_eta.size(); ++im) {\n",
    "            if (std::abs(m_eta[im]) < 1.5 && m_pt[im] > 9) {\n",
    "                go = true;\n",
    "                break;\n",
    "            }\n",
    "        }\n",
    "    } else {\n",
    "        go = true;\n",
    "    }\n",
    "    for (size_t i = 0; i < g_id.size(); ++i) {\n",
    "        if (st[i] == 1) {\n",
    "            int midx = g_midx[i];\n",
    "            if (g_id[i] == id1 && std::abs(g_id[midx]) == 421) {\n",
    "                int gmidx = g_midx[midx];\n",
    "                if (std::abs(g_id[gmidx]) == 521) {\n",
    "                    PtEtaPhiMVector GenP(g_pt[i], g_eta[i], g_phi[i], pdg->GetParticle(g_id[i])->Mass());\n",
    "                    float dist = TMath::Sqrt(g_vx[i] * g_vx[i] + g_vy[i] * g_vy[i] + g_vz[i] * g_vz[i]);\n",
    "                    d[gmidx].emplace_back(GenP, midx, 1, g_pt[i], dist);\n",
    "                }\n",
    "            } else if (g_id[i] == id2 && std::abs(g_id[midx]) == 421) {\n",
    "                int gmidx = g_midx[midx];\n",
    "                if (std::abs(g_id[gmidx]) == 521) {\n",
    "                    PtEtaPhiMVector GenP(g_pt[i], g_eta[i], g_phi[i], pdg->GetParticle(g_id[i])->Mass());\n",
    "                    float dist = TMath::Sqrt(g_vx[i] * g_vx[i] + g_vy[i] * g_vy[i] + g_vz[i] * g_vz[i]);\n",
    "                    d[gmidx].emplace_back(GenP, midx, 2, g_pt[i], dist);\n",
    "                }\n",
    "            } else if (g_id[i] == -id3 && g_id[midx] == -521) {\n",
    "                PtEtaPhiMVector GenP(g_pt[i], g_eta[i], g_phi[i], pdg->GetParticle(g_id[i])->Mass());\n",
    "                float dist = TMath::Sqrt(g_vx[i] * g_vx[i] + g_vy[i] * g_vy[i] + g_vz[i] * g_vz[i]);\n",
    "                d[midx].emplace_back(GenP, midx, 3, g_pt[i], dist);\n",
    "            } else if (g_id[i] == id3 && g_id[midx] == 521) {\n",
    "                PtEtaPhiMVector GenP(g_pt[i], g_eta[i], g_phi[i], pdg->GetParticle(g_id[i])->Mass());\n",
    "                float dist = TMath::Sqrt(g_vx[i] * g_vx[i] + g_vy[i] * g_vy[i] + g_vz[i] * g_vz[i]);\n",
    "                d[midx].emplace_back(GenP, midx, 3, g_pt[i], dist);\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    for (const auto& pair : d) {\n",
    "        int B = pair.first;\n",
    "        const auto& parts = pair.second;\n",
    "        if (parts.size() == 3) {\n",
    "            for (const auto& e : parts) {\n",
    "                int typ = std::get<2>(e);\n",
    "                if (typ == 1) {\n",
    "                    B_den_pt.push_back(g_pt[B]);\n",
    "                    D_den_pt.push_back(g_pt[std::get<1>(e)]);\n",
    "                    d1_den_pt.push_back(std::get<3>(e));\n",
    "                    d1_den_d.push_back(std::get<4>(e));\n",
    "                    Gp.push_back(e);\n",
    "                } else if (typ == 2) {\n",
    "                    d2_den_pt.push_back(std::get<3>(e));\n",
    "                    d2_den_d.push_back(std::get<4>(e));\n",
    "                    Gm.push_back(e);\n",
    "                } else {\n",
    "                    d3_den_pt.push_back(std::get<3>(e));\n",
    "                    d3_den_d.push_back(std::get<4>(e));\n",
    "                    if (g_id[B] > 0) {\n",
    "                        Gp.push_back(e);\n",
    "                    } else {\n",
    "                        Gm.push_back(e);\n",
    "                    }\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    if (go) {\n",
    "        std::vector<PtEtaPhiMVector> Tp, Tm;\n",
    "        for (size_t it = 0; it < t_ch.size(); ++it) {\n",
    "            PtEtaPhiMVector Track(t_pt[it], t_eta[it], t_phi[it], t_mass[it]);\n",
    "            if (t_ch[it] == 1) Tp.push_back(Track);\n",
    "            else if (t_ch[it] == -1) Tm.push_back(Track);\n",
    "        }\n",
    "        std::vector<Matched> m1a, m2a, m3a;\n",
    "        // ****** CORREZIONE 2: Passa id1, id2, id3 alla funzione ******\n",
    "        matching_func(Gp, Tp, d1_num_pt, d2_num_pt, d3_num_pt, d1_num_d, d2_num_d, d3_num_d, d1_dr, d2_dr, d3_dr, m1a, m2a, m3a, th1, th2, th3, id1, id2, id3);\n",
    "        std::vector<Matched> m1b, m2b, m3b;\n",
    "        // ****** CORREZIONE 3: Passa id1, id2, id3 anche alla seconda chiamata ******\n",
    "        matching_func(Gm, Tm, d1_num_pt, d2_num_pt, d3_num_pt, d1_num_d, d2_num_d, d3_num_d, d1_dr, d2_dr, d3_dr, m1b, m2b, m3b, th1, th2, th3, id1, id2, id3);\n",
    "        \n",
    "        std::vector<Matched> m1; m1.reserve(m1a.size() + m1b.size()); m1.insert(m1.end(), m1a.begin(), m1a.end()); m1.insert(m1.end(), m1b.begin(), m1b.end());\n",
    "        std::vector<Matched> m2; m2.reserve(m2a.size() + m2b.size()); m2.insert(m2.end(), m2a.begin(), m2a.end()); m2.insert(m2.end(), m2b.begin(), m2b.end());\n",
    "        std::vector<Matched> m3; m3.reserve(m3a.size() + m3b.size()); m3.insert(m3.end(), m3a.begin(), m3a.end()); m3.insert(m3.end(), m3b.begin(), m3b.end());\n",
    "        for (const auto& e : m1) {\n",
    "            const auto& reco = std::get<2>(e);\n",
    "            d1_pt.push_back(reco.Pt());\n",
    "            d1_eta.push_back(reco.Eta());\n",
    "            d1_phi.push_back(reco.Phi());\n",
    "        }\n",
    "        for (const auto& e : m2) {\n",
    "            const auto& reco = std::get<2>(e);\n",
    "            d2_pt.push_back(reco.Pt());\n",
    "            d2_eta.push_back(reco.Eta());\n",
    "            d2_phi.push_back(reco.Phi());\n",
    "        }\n",
    "        for (const auto& e : m3) {\n",
    "            const auto& reco = std::get<2>(e);\n",
    "            d3_pt.push_back(reco.Pt());\n",
    "            d3_eta.push_back(reco.Eta());\n",
    "            d3_phi.push_back(reco.Phi());\n",
    "        }\n",
    "        std::vector<Matched> mD = matching_m(g_eta, g_phi, g_pt, g_mass, g_midx, m1, m2, D_den_pt, D_num_pt, D_dr, 0.05f, D_M);\n",
    "        std::vector<Matched> mB = matching_m(g_eta, g_phi, g_pt, g_mass, g_midx, mD, m3, B_den_pt, B_num_pt, B_dr, 0.05f, B_M);\n",
    "    }\n",
    "    std::vector<RVec<float>> results;\n",
    "    results.reserve(32);\n",
    "    results.push_back(d1_num_pt);\n",
    "    results.push_back(d2_num_pt);\n",
    "    results.push_back(d3_num_pt);\n",
    "    results.push_back(d1_num_d);\n",
    "    results.push_back(d2_num_d);\n",
    "    results.push_back(d3_num_d);\n",
    "    results.push_back(d1_den_pt);\n",
    "    results.push_back(d2_den_pt);\n",
    "    results.push_back(d3_den_pt);\n",
    "    results.push_back(d1_den_d);\n",
    "    results.push_back(d2_den_d);\n",
    "    results.push_back(d3_den_d);\n",
    "    results.push_back(d1_dr);\n",
    "    results.push_back(d2_dr);\n",
    "    results.push_back(d3_dr);\n",
    "    results.push_back(B_num_pt);\n",
    "    results.push_back(D_num_pt);\n",
    "    results.push_back(B_den_pt);\n",
    "    results.push_back(D_den_pt);\n",
    "    results.push_back(B_dr);\n",
    "    results.push_back(D_dr);\n",
    "    results.push_back(B_M);\n",
    "    results.push_back(D_M);\n",
    "    results.push_back(d1_eta);\n",
    "    results.push_back(d2_eta);\n",
    "    results.push_back(d3_eta);\n",
    "    results.push_back(d1_phi);\n",
    "    results.push_back(d2_phi);\n",
    "    results.push_back(d3_phi);\n",
    "    results.push_back(d1_pt);\n",
    "    results.push_back(d2_pt);\n",
    "    results.push_back(d3_pt);\n",
    "    return results;\n",
    "}\n",
    "\"\"\"\n",
    "\n",
    "# Declare the C++ code\n",
    "ROOT.gInterpreter.Declare(cpp_code)\n",
    "\n",
    "# Define the RDataFrame with the correct number of arguments\n",
    "df1 = df.Define(\"results\", \"main_func(GenPart_pt, GenPart_eta, GenPart_phi, GenPart_mass, GenPart_pdgId, GenPart_status, GenPart_genPartIdxMother, Track_pt, Track_eta, Track_phi, Track_charge, Track_mass, GenPart_vx, GenPart_vy, GenPart_vz, AllMuon_eta, AllMuon_pt, {}, {}, {}, {}, {}, {}, {})\".format(1 if t else 0, id1, id2, id3, th1, th2, th3)) \\\n",
    "        .Define(\"d1_num_pt\", \"results[0]\") \\\n",
    "        .Define(\"d2_num_pt\", \"results[1]\") \\\n",
    "        .Define(\"d3_num_pt\", \"results[2]\") \\\n",
    "        .Define(\"d1_num_d\", \"results[3]\") \\\n",
    "        .Define(\"d2_num_d\", \"results[4]\") \\\n",
    "        .Define(\"d3_num_d\", \"results[5]\") \\\n",
    "        .Define(\"d1_den_pt\", \"results[6]\") \\\n",
    "        .Define(\"d2_den_pt\", \"results[7]\") \\\n",
    "        .Define(\"d3_den_pt\", \"results[8]\") \\\n",
    "        .Define(\"d1_den_d\", \"results[9]\") \\\n",
    "        .Define(\"d2_den_d\", \"results[10]\") \\\n",
    "        .Define(\"d3_den_d\", \"results[11]\") \\\n",
    "        .Define(\"d1_dr\", \"results[12]\") \\\n",
    "        .Define(\"d2_dr\", \"results[13]\") \\\n",
    "        .Define(\"d3_dr\", \"results[14]\") \\\n",
    "        .Define(\"B_num_pt\", \"results[15]\") \\\n",
    "        .Define(\"D_num_pt\", \"results[16]\") \\\n",
    "        .Define(\"B_den_pt\", \"results[17]\") \\\n",
    "        .Define(\"D_den_pt\", \"results[18]\") \\\n",
    "        .Define(\"B_dr\", \"results[19]\") \\\n",
    "        .Define(\"D_dr\", \"results[20]\") \\\n",
    "        .Define(\"B_M\", \"results[21]\") \\\n",
    "        .Define(\"D_M\", \"results[22]\") \\\n",
    "        .Define(\"d1_eta\", \"results[23]\") \\\n",
    "        .Define(\"d2_eta\", \"results[24]\") \\\n",
    "        .Define(\"d3_eta\", \"results[25]\") \\\n",
    "        .Define(\"d1_phi\", \"results[26]\") \\\n",
    "        .Define(\"d2_phi\", \"results[27]\") \\\n",
    "        .Define(\"d3_phi\", \"results[28]\") \\\n",
    "        .Define(\"d1_pt\", \"results[29]\") \\\n",
    "        .Define(\"d2_pt\", \"results[30]\") \\\n",
    "        .Define(\"d3_pt\", \"results[31]\")\n",
    "\n",
    "# Suppress dictionary warnings\n",
    "ROOT.gErrorIgnoreLevel = ROOT.kError\n",
    "\n",
    "# Lista dei branch per cui creare istogrammi\n",
    "branches = [\"d1_num_pt\", \"d2_num_pt\", \"d3_num_pt\", \"d1_den_pt\", \"d2_den_pt\", \"d3_den_pt\", \"d1_dr\", \"d2_dr\", \"d3_dr\", \"B_num_pt\", \"D_num_pt\", \"B_den_pt\", \"D_den_pt\", \"B_dr\", \"D_dr\",\"B_M\",\"D_M\",\"d1_pt\",\"d2_pt\",\"d3_pt\",\"d1_eta\",\"d2_eta\",\"d3_eta\",\"d1_phi\",\"d2_phi\",\"d3_phi\"]\n",
    "\n",
    "binning = {\n",
    "    \"d1_eta\": (100, -2.5, 2.5),\n",
    "    \"d1_phi\": (100, -4, 4),\n",
    "    \"d2_eta\": (100, -2.5, 2.5),\n",
    "    \"d2_phi\": (100, -4, 4),\n",
    "    \"d3_eta\": (100, -2.5, 2.5),\n",
    "    \"d3_phi\": (100, -4, 4),\n",
    "    \"d1_dr\": (100,0,0.05),\n",
    "    \"d2_dr\": (100,0,0.05),\n",
    "    \"d3_dr\": (100,0,0.05),\n",
    "    \"B_dr\": (100,0,0.1),\n",
    "    \"D_dr\": (100,0,0.1),\n",
    "    \"B_M\": (100,4,6),\n",
    "    \"D_M\": (100,0,3)\n",
    "}\n",
    "\n",
    "# 1. Dichiara tutti gli istogrammi senza chiamare GetValue()\n",
    "histo_pointers = {}\n",
    "print(\"Booking all histograms...\")\n",
    "for branch in branches:\n",
    "    nbins, min_val, max_val = binning.get(branch, (100, 0, 25)) # Default se non specificato\n",
    "    hist_name = f\"hist_{branch}\"\n",
    "    model = ROOT.RDF.TH1DModel(hist_name, f\"{branch};Value;Entries\", nbins, min_val, max_val)\n",
    "    histo_pointers[branch] = df1.Histo1D(model, branch)\n",
    "\n",
    "# 2. Triggera il calcolo\n",
    "print(\"Triggering event loop to fill all histograms...\")\n",
    "f = {}\n",
    "for branch, ptr in histo_pointers.items():\n",
    "    print(f\"Retrieving histogram for {branch}...\")\n",
    "    f[branch] = ptr.GetValue()\n",
    "\n",
    "# 3. Salva tutto\n",
    "print(\"Saving histograms to file...\")\n",
    "out_file = ROOT.TFile(\"histograms\"+decay+\".root\", \"RECREATE\")\n",
    "for hist in f.values():\n",
    "    hist.Write()\n",
    "out_file.Close()\n",
    "print(f\"All histograms saved in histograms{decay}.root\")\n",
    "end = time.time()\n",
    "print(f\"Tempo di esecuzione: {end - start:.3f} secondi\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "44fde663",
   "metadata": {},
   "outputs": [],
   "source": [
    "name=\"Plots_\"+decay\n",
    "os.system(\"mkdir -p \"+name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8033ddf9",
   "metadata": {},
   "outputs": [],
   "source": [
    "c_eff = TCanvas(\"c_eff\", \"d1 Efficiency\", 700, 500)\n",
    "num = f[\"d1_num_pt\"]\n",
    "den = f[\"d1_den_pt\"]\n",
    "eff = ROOT.TEfficiency(num, den)\n",
    "eff.SetTitle(\"Efficiency d1 vs pT; pT [GeV]; Efficiency\")\n",
    "eff.Draw()\n",
    "c_eff.SaveAs(name+\"/efficiency_d1_vs_pt.png\")\n",
    "c_eff.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8b8e1e8a",
   "metadata": {},
   "outputs": [],
   "source": [
    "c_eff = TCanvas(\"c_eff\", \"d2 Efficiency\", 700, 500)\n",
    "num = f[\"d2_num_pt\"]\n",
    "den = f[\"d2_den_pt\"]\n",
    "eff = ROOT.TEfficiency(num, den)\n",
    "eff.SetTitle(\"Efficiency d2 vs pT; pT [GeV]; Efficiency\")\n",
    "eff.Draw()\n",
    "c_eff.SaveAs(name+\"/efficiency_d2_vs_pt.png\")\n",
    "c_eff.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a584f6ef",
   "metadata": {},
   "outputs": [],
   "source": [
    "c_eff = TCanvas(\"c_eff\", \"d3 Efficiency\", 700, 500)\n",
    "num = f[\"d3_num_pt\"]\n",
    "den = f[\"d3_den_pt\"]\n",
    "eff = ROOT.TEfficiency(num, den)\n",
    "eff.SetTitle(\"Efficiency d3 vs pT; pT [GeV]; Efficiency\")\n",
    "eff.Draw()\n",
    "c_eff.SaveAs(name+\"/efficiency_d3_vs_pt.png\")\n",
    "c_eff.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "13b1e596",
   "metadata": {},
   "outputs": [],
   "source": [
    "c_eff = TCanvas(\"c_eff\", \"D Efficiency pt\", 700, 500)\n",
    "num = f[\"D_num_pt\"]\n",
    "den = f[\"D_den_pt\"]\n",
    "eff = ROOT.TEfficiency(num, den)\n",
    "eff.SetTitle(\"Efficiency D vs pt; pt [Gev]; Efficiency\")\n",
    "eff.Draw()\n",
    "c_eff.SaveAs(name+\"/efficiency_D_vs_pt.png\")\n",
    "c_eff.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e150a4c2",
   "metadata": {},
   "outputs": [],
   "source": [
    "c_eff = TCanvas(\"c_eff\", \"B Efficiency pt\", 700, 500)\n",
    "num = f[\"B_num_pt\"]\n",
    "den = f[\"B_den_pt\"]\n",
    "eff = ROOT.TEfficiency(num, den)\n",
    "eff.SetTitle(\"Efficiency B vs pt; pt [Gev]; Efficiency\")\n",
    "eff.Draw()\n",
    "c_eff.SaveAs(name+\"/efficiency_B_vs_pt.png\")\n",
    "c_eff.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2203aeca",
   "metadata": {},
   "outputs": [],
   "source": [
    "c0=TCanvas(\"c0\",\"pt distributions\",200,10,700,500)\n",
    "c0.cd()\n",
    "hd1=f[\"d1_pt\"]\n",
    "hd2=f[\"d2_pt\"]\n",
    "hd3=f[\"d3_pt\"]\n",
    "print(hd1.Integral())\n",
    "print(hd2.Integral())\n",
    "print(hd3.Integral())\n",
    "hd1.SetLineColor(2)\n",
    "hd2.SetLineColor(4)\n",
    "hd3.SetLineColor(6)\n",
    "hd1.SetStats(0) \n",
    "hd1.Draw()\n",
    "hd2.Draw(\"same\")\n",
    "hd3.Draw(\"same\")\n",
    "hd1.SetTitle(\"Pt distributions\")\n",
    "hd1.GetXaxis().SetTitle(\"p_{t} [Gev/c]\")\n",
    "hd1.GetYaxis().SetTitle(\"number of tracks\")\n",
    "legend=TLegend(0.7,0.8,0.85,0.6)\n",
    "legend.AddEntry(hd1,\"d1 p_{t}\")\n",
    "legend.AddEntry(hd2,\"d2 p_{t}\")\n",
    "legend.AddEntry(hd3,\"d3 p_{t}\")\n",
    "ROOT.gStyle.SetLegendTextSize(0.05)\n",
    "legend.Draw()\n",
    "c0.Draw()\n",
    "c0.SaveAs(name+\"/pt_distributions.png\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1fe93396",
   "metadata": {},
   "outputs": [],
   "source": [
    "c0=TCanvas(\"c0\",\"eta distributions\",200,10,700,500)\n",
    "c0.cd()\n",
    "hd1=f[\"d1_eta\"]\n",
    "hd2=f[\"d2_eta\"]\n",
    "hd3=f[\"d3_eta\"]\n",
    "print(hd1.Integral())\n",
    "print(hd2.Integral())\n",
    "print(hd3.Integral())\n",
    "hd1.SetLineColor(2)\n",
    "hd2.SetLineColor(4)\n",
    "hd3.SetLineColor(6)\n",
    "hd1.SetStats(0) \n",
    "hd1.Draw()\n",
    "hd2.Draw(\"same\")\n",
    "hd3.Draw(\"same\")\n",
    "hd1.SetTitle(\"Eta distributions\")\n",
    "hd1.GetXaxis().SetTitle(\"Eta\")\n",
    "hd1.GetYaxis().SetTitle(\"number of tracks\")\n",
    "legend=TLegend(0.7,0.8,0.85,0.6)\n",
    "legend.AddEntry(hd1,\"d1 eta\")\n",
    "legend.AddEntry(hd2,\"d2 eta\")\n",
    "legend.AddEntry(hd3,\"d3 eta\")\n",
    "ROOT.gStyle.SetLegendTextSize(0.05)\n",
    "legend.Draw()\n",
    "c0.Draw()\n",
    "c0.SaveAs(name+\"/eta_distributions.png\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c334a33a",
   "metadata": {},
   "outputs": [],
   "source": [
    "c0=TCanvas(\"c0\",\"phi distributions\",200,10,700,500)\n",
    "c0.cd()\n",
    "hd1=f[\"d1_phi\"]\n",
    "hd2=f[\"d2_phi\"]\n",
    "hd3=f[\"d3_phi\"]\n",
    "print(hd1.Integral())\n",
    "print(hd2.Integral())\n",
    "print(hd3.Integral())\n",
    "hd1.SetLineColor(2)\n",
    "hd2.SetLineColor(4)\n",
    "hd3.SetLineColor(6)\n",
    "hd1.SetStats(0) \n",
    "hd1.Draw()\n",
    "hd2.Draw(\"same\")\n",
    "hd3.Draw(\"same\")\n",
    "hd1.SetTitle(\"Phi distributions\")\n",
    "hd1.GetXaxis().SetTitle(\"phi [rad]\")\n",
    "hd1.GetYaxis().SetTitle(\"number of tracks\")\n",
    "legend=TLegend(0.7,0.8,0.85,0.6)\n",
    "legend.AddEntry(hd1,\"d1 phi\")\n",
    "legend.AddEntry(hd2,\"d2 phi\")\n",
    "legend.AddEntry(hd3,\"d3 phi\")\n",
    "ROOT.gStyle.SetLegendTextSize(0.05)\n",
    "legend.Draw()\n",
    "c0.Draw()\n",
    "c0.SaveAs(name+\"/phi_distributions.png\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3f2d0d3d",
   "metadata": {},
   "outputs": [],
   "source": [
    "c = ROOT.TCanvas(\"c\", \"D invariant mass\", 700, 500)\n",
    "hist = f[\"D_M\"]\n",
    "hist.SetLineColor(ROOT.kBlue)\n",
    "hist.SetTitle(\"D_M; Invariant mass [GeV]; Entries\")\n",
    "hist.Draw()\n",
    "c.SaveAs(name+\"/D_M.png\")\n",
    "c.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b7d34d93",
   "metadata": {},
   "outputs": [],
   "source": [
    "c = ROOT.TCanvas(\"c\", \"B invariant mass\", 700, 500)\n",
    "hist = f[\"B_M\"]\n",
    "hist.SetLineColor(ROOT.kBlue)\n",
    "hist.SetTitle(\"B_M; Invariant mass [GeV]; Entries\")\n",
    "hist.Draw()\n",
    "c.SaveAs(name+\"/B_M.png\")\n",
    "c.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "969b2208",
   "metadata": {},
   "outputs": [],
   "source": [
    "c = ROOT.TCanvas(\"c\", \"dr distribution d1\", 700, 500)\n",
    "hist = f[\"d1_dr\"]\n",
    "hist.SetLineColor(ROOT.kBlue)\n",
    "hist.SetTitle(\"d1_dr;Angular Distance; Entries\")\n",
    "hist.Draw()\n",
    "c.SaveAs(\"Plots/d1_dr.png\")\n",
    "c.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d3afd8e0",
   "metadata": {},
   "outputs": [],
   "source": [
    "c = ROOT.TCanvas(\"c\", \"dr distribution d2\", 700, 500)\n",
    "hist = f[\"d2_dr\"]\n",
    "hist.SetLineColor(ROOT.kBlue)\n",
    "hist.SetTitle(\"d2_dr;Angular Distance; Entries\")\n",
    "hist.Draw()\n",
    "c.SaveAs(name+\"/d2_dr.png\")\n",
    "c.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e7ca77d7",
   "metadata": {},
   "outputs": [],
   "source": [
    "c = ROOT.TCanvas(\"c\", \"dr distribution d3\", 700, 500)\n",
    "hist = f[\"d3_dr\"]\n",
    "hist.SetLineColor(ROOT.kBlue)\n",
    "hist.SetTitle(\"d3_dr;Angular Distance; Entries\")\n",
    "hist.Draw()\n",
    "c.SaveAs(name+\"/d3_dr.png\")\n",
    "c.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d0f108d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "c = ROOT.TCanvas(\"c\", \"dr distribution D\", 700, 500)\n",
    "hist = f[\"D_dr\"]\n",
    "hist.SetLineColor(ROOT.kBlue)\n",
    "hist.SetTitle(\"D_dr;Angular Distance; Entries\")\n",
    "hist.Draw()\n",
    "c.SaveAs(name+\"/D_dr.png\")\n",
    "c.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9282636f",
   "metadata": {},
   "outputs": [],
   "source": [
    "c = ROOT.TCanvas(\"c\", \"dr distribution B\", 700, 500)\n",
    "hist = f[\"B_dr\"]\n",
    "hist.SetLineColor(ROOT.kBlue)\n",
    "hist.SetTitle(\"B_dr;Angular Distance; Entries\")\n",
    "hist.Draw()\n",
    "c.SaveAs(name+\"/B_dr.png\")\n",
    "c.Draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "84e133d0",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "be06479b",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4c43e44e",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9c32b9ce",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4548724c",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "c_eff = TCanvas(\"c_eff\", \"d1 Efficiency d\", 700, 500)\n",
    "num = f[\"d1_num_d\"]\n",
    "den = f[\"d1_den_d\"]\n",
    "eff = ROOT.TEfficiency(num, den)\n",
    "eff.SetTitle(\"Efficiency d1 vs d; d [cm]; Efficiency\")\n",
    "eff.Draw()\n",
    "c_eff.SaveAs(name+\"/efficiency_d1_vs_d.png\")\n",
    "c_eff.Draw()\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "189ca94d",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "c_eff = TCanvas(\"c_eff\", \"d2 Efficiency d\", 700, 500)\n",
    "num = f[\"d2_num_d\"]\n",
    "den = f[\"d2_den_d\"]\n",
    "eff = ROOT.TEfficiency(num, den)\n",
    "eff.SetTitle(\"Efficiency d2 vs d; d [cm]; Efficiency\")\n",
    "eff.Draw()\n",
    "c_eff.SaveAs(name+\"/efficiency_d2_vs_d.png\")\n",
    "c_eff.Draw()\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8673a634",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "c_eff = TCanvas(\"c_eff\", \"d3 Efficiency d\", 700, 500)\n",
    "num = f[\"d3_num_d\"]\n",
    "den = f[\"d3_den_d\"]\n",
    "eff = ROOT.TEfficiency(num, den)\n",
    "eff.SetTitle(\"Efficiency d3 vs d; d [cm]; Efficiency\")\n",
    "eff.Draw()\n",
    "c_eff.SaveAs(name+\"/efficiency_d3_vs_d.png\")\n",
    "c_eff.Draw()\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b52e180f",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "44c8182d",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d7359fc9",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "31c4e5dc",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "@webio": {
   "lastCommId": null,
   "lastKernelId": null
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
